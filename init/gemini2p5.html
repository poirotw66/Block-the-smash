<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Badminton Defense</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #1a472a; /* Court Green */
            color: #fff;
            font-family: 'Verdana', sans-serif;
            cursor: none;
        }
        canvas {
            display: block;
        }
        #ui-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            text-shadow: 0 1px 3px rgba(0,0,0,0.8);
        }
        #score {
            position: absolute;
            top: 20px;
            left: 20px;
            font-size: 2em;
            color: #fff;
            font-weight: bold;
        }
        #game-over-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            display: none;
            justify-content: center;
            align-items: center;
            text-align: center;
            flex-direction: column;
            pointer-events: all;
            backdrop-filter: blur(4px);
        }
        #game-over-overlay h1 {
            font-size: 4em;
            margin: 0;
            color: #fff;
            border-bottom: 3px solid #fff;
            padding-bottom: 10px;
        }
        #restart-button {
            padding: 15px 40px;
            font-size: 1.5em;
            background-color: #fff;
            border: none;
            color: #1a472a;
            cursor: pointer;
            margin-top: 30px;
            font-weight: bold;
            border-radius: 50px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }
        #restart-button:hover {
            transform: scale(1.05);
        }
    </style>
</head>
<body>

    <div id="ui-container">
        <div id="score">HITS: 0 / 25</div>
        <div id="game-over-overlay">
            <h1>FINISHED</h1>
            <div id="final-stats" style="margin: 20px; font-size: 24px;"></div>
            <button id="restart-button">NEW DRILL</button>
        </div>
    </div>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- GAME STATE & CONSTANTS ---
        const scene = new THREE.Scene();
        // Defensive Stance Camera
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 1, 12); 
        camera.rotation.order = 'YXZ';
        camera.rotation.x = -15 * Math.PI / 180; // Pitch Down
        camera.rotation.y = 10 * Math.PI / 180;  // Yaw Right
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        
        let hits = 0;
        let maxBalls = 25;
        let spawnedBalls = 0;
        let isMatchActive = true;
        let mouseX = 0;
        let mouseY = 0;
        let handedness = 'right';
        
        let isSwinging = false;
        let swingTimer = 0;
        const SWING_DURATION = 15; // Frames
        
        const ENEMY_SPAWN_RATE = 400; // Faster spawn (400ms)
        let lastEnemySpawn = 0;
        
        let isPaused = false;
        window.addEventListener('message', (e) => {
             if (e.data && e.data.type === 'PAUSE_GAME') {
                 isPaused = e.data.payload;
                 if (!isPaused) clock.getDelta();
             }
             if (e.data && e.data.type === 'SET_HANDEDNESS') {
                 handedness = e.data.payload;
             }
             if (e.data && e.data.type === 'START_MATCH') {
                 startMatch(e.data.payload);
             }
        });

        // --- SCENE SETUP ---
        function setupScene() {
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.body.appendChild(renderer.domElement);

            scene.background = new THREE.Color(0x1a472a); // Green
            scene.fog = new THREE.Fog(0x1a472a, 20, 150);
            
            // Court Lines
            const grid = new THREE.GridHelper(200, 40, 0xffffff, 0x225533);
            grid.position.y = -5; // Lower floor
            scene.add(grid);
            
            // Net (Visual Guide)
            const netGeo = new THREE.BoxGeometry(60, 5, 0.1);
            const net = new THREE.Mesh(netGeo, new THREE.MeshBasicMaterial({color: 0xcccccc, wireframe: true, transparent: true, opacity: 0.3}));
            net.position.set(0, -1, -40);
            scene.add(net);
            // Tape
            const tape = new THREE.Mesh(new THREE.BoxGeometry(60, 0.2, 0.1), new THREE.MeshBasicMaterial({color: 0xffffff}));
            tape.position.set(0, 2.5, 0); // Relative to net center (approx Y=1.5 world)
            net.add(tape);
            
            const ambient = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambient);
            const dir = new THREE.DirectionalLight(0xffffff, 0.5);
            dir.position.set(0, 10, 5);
            scene.add(dir);
        }
        
        // --- POST-PROCESSING ---
        const renderScene = new RenderPass(scene, camera);
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0.7;
        bloomPass.strength = 0.4;
        bloomPass.radius = 0.5;
        
        const composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        // --- PLAYER RACKET ---
        class Racket {
            constructor() {
                // Hand Position (Pivot)
                this.hand = new THREE.Group();
                scene.add(this.hand);

                // Wrist Pivot (Rotation)
                this.wrist = new THREE.Group();
                this.hand.add(this.wrist);

                // Visuals (Offset)
                this.visuals = new THREE.Group();
                this.visuals.position.y = 5.0; // Offset head away from hand
                this.wrist.add(this.visuals);

                // Head
                const headGeo = new THREE.TorusGeometry(2, 0.2, 8, 24);
                const headMat = new THREE.MeshStandardMaterial({ color: 0xcccccc, metalness: 0.5 });
                const head = new THREE.Mesh(headGeo, headMat);
                head.scale.y = 1.3;
                this.visuals.add(head);
                
                // Save reference to head mesh for hit detection
                this.headMesh = head;
                
                // Strings (Generate Grid Texture)
                function createStringTexture() {
                    const canvas = document.createElement('canvas');
                    canvas.width = 512;
                    canvas.height = 512;
                    const ctx = canvas.getContext('2d');
                    
                    // Clear
                    ctx.clearRect(0, 0, 512, 512);
                    
                    // Grid Lines
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 4;
                    
                    const step = 32;
                    for(let i=0; i<=512; i+=step) {
                        ctx.beginPath();
                        ctx.moveTo(i, 0); ctx.lineTo(i, 512);
                        ctx.stroke();
                        
                        ctx.beginPath();
                        ctx.moveTo(0, i); ctx.lineTo(512, i);
                        ctx.stroke();
                    }
                    
                    const tex = new THREE.CanvasTexture(canvas);
                    return tex;
                }

                // Use CircleGeometry to fill the Torus hole properly
                const sGeo = new THREE.CircleGeometry(1.9, 32); 
                const sMat = new THREE.MeshBasicMaterial({ 
                    map: createStringTexture(), 
                    color: 0xeeeeee, 
                    transparent: true, 
                    opacity: 0.7, // Visible
                    side: THREE.DoubleSide
                });
                const strings = new THREE.Mesh(sGeo, sMat);
                strings.scale.set(1, 1.3, 1); // Match frame
                this.visuals.add(strings);

                // Handle
                const hGeo = new THREE.CylinderGeometry(0.2, 0.2, 4);
                const hMat = new THREE.MeshStandardMaterial({ color: 0x222222 });
                const handle = new THREE.Mesh(hGeo, hMat);
                handle.position.y = -4.25;
                this.visuals.add(handle);
            }
            
            update() {
                // Orientation
                if (handedness === 'left') {
                    this.visuals.rotation.z = -Math.PI / 2;
                } else {
                    this.visuals.rotation.z = Math.PI / 2;
                }

                // Movement (Hand position)
                const rangeX = 14;
                const rangeY = 6;
                const centerX = (handedness === 'right') ? 4 : -4;

                const targetX = centerX + (mouseX * rangeX);
                const targetY = -1 + (mouseY * rangeY);

                this.hand.position.x += (targetX - this.hand.position.x) * 0.25;
                this.hand.position.y += (targetY - this.hand.position.y) * 0.25;
                
                // Swing Logic
                if (isSwinging) {
                    swingTimer++;
                    const progress = swingTimer / SWING_DURATION;
                    
                    const snap = Math.sin(progress * Math.PI);
                    
                    // Wrist Snap
                    this.wrist.rotation.x = -snap * 0.8;
                    
                    // Push
                    this.hand.position.z = 4 - (snap * 2.0);
                    
                    if (swingTimer >= SWING_DURATION) {
                        isSwinging = false;
                        this.wrist.rotation.x = 0;
                        this.hand.position.z = 4;
                    }
                } else {
                     this.hand.position.z = 4;
                     this.hand.rotation.z = (this.hand.position.x - targetX) * 0.05;
                }
            }
            
            reset() {
                const centerX = (handedness === 'right') ? 4 : -4;
                this.hand.position.set(centerX, -1, 4);
                isSwinging = false;
            }
        }
        const player = new Racket();
        
        // --- OBJECT POOLING ---
        class ObjectPool {
            constructor(objectClass, initialSize) {
                this.pool = [];
                this.active = [];
                for (let i = 0; i < initialSize; i++) {
                    const obj = new objectClass();
                    scene.remove(obj.mesh);
                    this.pool.push(obj);
                }
            }
            
            get() {
                let obj;
                if (this.pool.length > 0) obj = this.pool.pop();
                else obj = new this.pool[0].constructor();
                
                scene.add(obj.mesh);
                this.active.push(obj);
                return obj;
            }
            
            release(obj) {
                const index = this.active.indexOf(obj);
                if (index > -1) {
                    this.active.splice(index, 1);
                    scene.remove(obj.mesh);
                    this.pool.push(obj);
                }
            }
            
            update(...args) {
                for (let i = this.active.length - 1; i >= 0; i--) {
                    if (!this.active[i].update(...args)) {
                        this.release(this.active[i]);
                    }
                }
            }
            
            clearAll() {
                 for (let i = this.active.length - 1; i >= 0; i--) {
                    this.release(this.active[i]);
                }
            }
        }
        

        // --- SHUTTLECOCK ---
        class Shuttle {
            constructor() {
                const group = new THREE.Group();
                // Cork
                const cGeo = new THREE.SphereGeometry(0.3);
                const cMat = new THREE.MeshStandardMaterial({ color: 0xffffff });
                group.add(new THREE.Mesh(cGeo, cMat));
                
                // Skirt
                const sGeo = new THREE.ConeGeometry(0.4, 0.6, 12, 1, true);
                const sMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.8, side: THREE.DoubleSide });
                const skirt = new THREE.Mesh(sGeo, sMat);
                skirt.position.y = 0.3;
                group.add(skirt);
                
                group.rotation.x = -Math.PI / 2; // Point at camera

                this.mesh = group;
                this.velocity = new THREE.Vector3();
                this.returning = false;
            }

            spawn() {
                // High Spawn
                this.mesh.position.set(THREE.MathUtils.randFloat(-20, 20), 12 + Math.random()*5, -120);
                
                // Target player roughly (Low defensive area)
                const targetX = player.hand.position.x + (Math.random()-0.5) * 5;
                const targetY = -2;
                
                this.velocity.subVectors(new THREE.Vector3(targetX, targetY, 4), this.mesh.position).normalize().multiplyScalar(2.5 + hits*0.05);
                this.returning = false;
                this.mesh.rotation.set(-Math.PI / 2, 0, 0); // Reset rotation
            }
            
            update() {
                this.mesh.position.add(this.velocity);
                
                if (this.velocity.lengthSq() > 0.1) {
                    const target = this.mesh.position.clone().add(this.velocity);
                    this.mesh.lookAt(target);
                }
                
                if (this.returning) {
                     if (this.mesh.position.z < -200) return false; // Remove when far away
                     this.velocity.y -= 0.5; // Gravity
                     return true;
                }

                // Check Collision with Racket
                const sweetSpot = new THREE.Vector3();
                player.headMesh.getWorldPosition(sweetSpot);
                const hitRadius = 3.5;

                if (isSwinging && this.mesh.position.z > -5 && this.mesh.position.z < 15) {
                    const d = this.mesh.position.distanceTo(sweetSpot);
                    if (d < hitRadius) {
                        // HIT!
                        hits++;
                        document.getElementById('score').textContent = `HITS: ${hits} / ${maxBalls}`;
                        // Spawn particles
                        const p = particlePool.get();
                        if (p) p.activate(this.mesh.position);
                        
                        // RETURN LOGIC
                        this.returning = true;
                        this.velocity.z = -Math.abs(this.velocity.z) * 0.9; 
                        this.velocity.y = Math.abs(this.velocity.y) + 8; // Lift
                        this.velocity.x += (Math.random()-0.5) * 8.0;
                        
                        return true;
                    }
                }
                
                // Missed
                if (this.mesh.position.z > 20) {
                    return false;
                }
                
                return true;
            }
        }
        const shuttlePool = new ObjectPool(Shuttle, 30);

        // --- PARTICLES ---
        class Particle {
            constructor() {
                const geometry = new THREE.PlaneGeometry(0.4, 0.4);
                const material = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide });
                this.mesh = new THREE.Mesh(geometry, material);
                this.life = 0;
                this.velocity = new THREE.Vector3();
            }
            
            activate(position) {
                this.mesh.position.copy(position);
                this.velocity.set((Math.random()-0.5), (Math.random()-0.5), (Math.random()) + 0.5);
                this.life = 30;
                this.mesh.rotation.set(Math.random(), Math.random(), Math.random());
            }
            
            update() {
                this.life--;
                this.mesh.position.add(this.velocity);
                this.mesh.scale.setScalar(this.life/30);
                this.mesh.rotation.x += 0.1;
                return this.life > 0;
            }
        }
        const particlePool = new ObjectPool(Particle, 50);

        // --- GAME LOGIC ---
        function startMatch(count) {
            hits = 0;
            maxBalls = count;
            spawnedBalls = 0;
            isMatchActive = true;
            player.reset();
            shuttlePool.clearAll();
            particlePool.clearAll();
            document.getElementById('game-over-overlay').style.display = 'none';
            document.getElementById('score').textContent = `HITS: 0 / ${maxBalls}`;
            document.body.style.cursor = 'none';
        }
        
        function finishMatch() {
            isMatchActive = false;
            document.getElementById('game-over-overlay').style.display = 'flex';
            
            const acc = Math.round((hits / maxBalls) * 100);
            document.getElementById('final-stats').innerHTML = `HITS: ${hits} / ${maxBalls}<br>ACCURACY: ${acc}%`;
            document.body.style.cursor = 'auto';
        }
        
        function replayDrill() {
            startMatch(maxBalls);
        }
        
        // --- CONTROLS ---
        window.addEventListener('mousemove', (e) => {
            mouseX = (e.clientX / window.innerWidth) * 2 - 1;
            mouseY = -(e.clientY / window.innerHeight) * 2 + 1;
        });
        window.addEventListener('mousedown', () => {
            if (isMatchActive && !isPaused && !isSwinging) {
                isSwinging = true;
                swingTimer = 0;
            }
        });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // --- ANIMATION ---
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            if (isPaused) return;

            const delta = clock.getDelta();

            if (isMatchActive) {
                player.update();
                shuttlePool.update();
                particlePool.update();
                
                // Spawn logic
                if (spawnedBalls < maxBalls && performance.now() - lastEnemySpawn > ENEMY_SPAWN_RATE) {
                    const s = shuttlePool.get();
                    if (s) {
                         s.spawn();
                         spawnedBalls++;
                    }
                    lastEnemySpawn = performance.now();
                }
                
                // Check End
                if (spawnedBalls >= maxBalls && shuttlePool.active.length === 0) {
                    finishMatch();
                }
            }

            composer.render(delta);
        }
        
        setupScene();
        document.getElementById('restart-button').addEventListener('click', replayDrill);
        
        // Initial Screen
        const overlay = document.getElementById('game-over-overlay');
        overlay.querySelector('h1').textContent = 'READY';
        overlay.querySelector('#final-stats').textContent = 'Waiting for selection...';
        overlay.style.display = 'flex';
    </script>
</body>
</html>